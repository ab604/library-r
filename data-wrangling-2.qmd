# Data wrangling II {#sec-data-wrangling-ii}

```{r}
#| label: dw2-set-up
#| echo: false
#| message: false
library(tidyverse)
library(palmerpenguins)
```

## Joins

[R4DS joins](https://r4ds.hadley.nz/joins) gives some detailed examples of joining tables, but here we'll look at some simpler examples to try build our mental model.

There are two types of join we often encounter:

1.  Joins that create new variables in one table by matching observations in another: these are *mutating* joins as per tidyverse verb `mutate` @sec-creating-new-columns-with-mutate.
2.  Joins that *filter* the observations from one table against another, as per tidyverse verb `filter` @sec-filter-rows-with-filter.

`dplyr` has six join functions.

Mutating joins:

1.  **Left Join**: Returns all rows from the left table and the matched rows from the right table. `left_join()`
2.  **Right Join**: Similar to left join, but returns all rows from the right table and the matched rows from the left table. `right_join()`
3.  **Full Join**: Returns all rows from both tables, with null values in the columns where there are no matches. `full_join()`

Filtering joins:

4.  **Inner Join**: Returns only the rows that have matches in both tables. `inner_join()`
5.  **Semi Join**: Returns only the rows from the left table that have matches in the right table. `semi_join()`
6.  **Anti Join**: Returns only the rows from the left table that do not have matches in the right table. `anti_join()`

## Mutating joins

To demonstrate a mutating join using the `penguins` data, I first use `mutate` to create a unique identifier variable for each penguin from the row number called `penguin_id`, and assign this to a new dataframe `numbered_penguins`.

Then I use `numbered_penguins` to create two new dataframes using `select`:

-   `penguins_physical` is a dataframe containing physical characteristics of penguins (e.g., bill length, flipper length, body mass).
-   `penguins_info` is a dataframe containing other information about penguins (e.g., species, island, year, sex).

```{r}
#| label: split-penguins
# Create unique id for each penguin
numbered_penguins <- penguins |> 
  mutate(penguin_id = row_number())

# Split the dataset into two tables
penguins_physical <- numbered_penguins |>
  select(penguin_id,species, island, bill_length_mm, 
         bill_depth_mm, flipper_length_mm, body_mass_g)

penguins_info <- numbered_penguins |>
  select(penguin_id,species, island, year, sex)
```

The common key that we can use to join these tables back together is the `penguin_id` variable. The mutation part is the creation of new variables when two tables are joined to create a single table.

Here we'll use the `left_join()` function to combine the two dataframes `penguins_physical` and `penguins_info` based on the `penguin_number` column, which is common to both dataframes.

We assign the result to a new dataframe, `penguins_joined`, which contains all the columns from `penguins_physical` and the matching columns from `penguins_info`.

The `left_join` function returns all records from the left dataframe (`penguins_physical`) and the matching records from the right dataframe (`penguins_info`). If there were no matches in the right dataframe, the result will contain null values for the right dataframe's columns.

```{r}
#| label: left-join
# Join the two tables back together as a left join
penguins_joined <- penguins_physical |>
  left_join(penguins_info)

# Print the joined dataset
glimpse(penguins_joined)
```

## Filtering join

Here we'll do a filtering join, a semi-join.

First I'll filter the `penguins_info` I created just for the data from the year 2008:

```{r}
#| label: penguins-2008
# Create a dataframe for penguins only for the year 2008
penguins_info_filt <- penguins_info |>
  filter(year == 2008)
```

Then we do a semi-join between the `penguins_physical` table and the filtered `penguins_info_filt` table.

A semi-join returns only the rows from `penguins_physical` that have a match in `penguins_info_filt`, effectively filtering the physical characteristics of penguins to only include those from 2008. This joins data from 114 rows of the 344 rows in the `penguins_physical`.

As we didn't explicitly tell the function which variables to use, we got a message tells us it joined `by = join_by(penguin_id, species, island)`

I've assigned the resulting table to a new dataframe: `penguins_filtered`.

```{r}
#| label: penguins-semi-join
# Perform a filtering join
penguins_filtered <- penguins_physical |>
  semi_join(penguins_info_filt)

# Print the filtered dataset
glimpse(penguins_filtered)
```

## Strings and characters

The terms strings and characters are often used interchangeably, but a character is technically a single symbol or glyph, such as **&** or **a**, or even ðŸ™€. And a sequence of characters and/or symbols form a string.

In R to create character vector, we enclose the characters forming the string in quotes. For example, `"hello"` is a string, and each individual character within it (`h`, `e`, `l`, `l`, `o`) is a character. `"hello"` is a character vector of length 1 as there is one string of five characters.

`"hello world"` is also a character vector of length 1 as the white space also counts as a character.

However using combine function `c()` to create `c("hello", "world")` would create a character vector of length 2 as we have now created `"hello"` and `"world"` as separate strings.

::: {.callout-note title="Single or double quotes?" appearance="simple"}
Both single `'` or double `"` are allowed, but for consistent style I'd recommend double, unless your string itself contains multiple `"` as per the [tidyverse style guide](https://style.tidyverse.org/syntax.html#character-vectors).
:::

### Regular expressions

A **regular expression** (regex) is a pattern used to match and manipulate strings. It's like a really powerful "find and replace" tool, but has completely unintuitive syntax!

You can use regex to specify a pattern, and then use that pattern to search for matches in a string. Once matched, we can extract or manipulate the strings in conjunction with other functions.

`stringr` is the tidyverse package for working with strings and regex. Many of the `stringr` functions allow us to avoid explicitly worrying about writing a regex, but we can always create a regex if needed.

Regex patterns consist of special characters, such as `.`, `*`, `+`, `?`, `{`, `}`, `[`, `]`, `(`, `)`, and `\`. These characters have special meanings, like "any character" ( `.` ), "zero or more" ( `*` ), or "start of string" ( `^` ). You can combine these characters to create complex patterns to match specific strings.

::: {.callout-warning title="Escaping regex special characters with backslash" appearance="simple"}
Because characters such dot `.` or asterisk `*` have special meaning in regex, if you want to treat them literally as a dot or asterisk, we have to *escape* their meta meaning.

To escape we use a backslash `\` before the special character such that to treat a dot as a dot we would write `\.` in our regex.
:::

### Getting started with `stringr`

To explore `stringr` we'll create a couple of character vectors:
Two character vectors are defined:

1. `cat_names`: a character vector of 20 strings of cat names
2. `ding_words`: a character vector of 20 words, all ending with `ding`.

```{r}
#| label: strings
# Twenty cat names
cat_names <- c("Whiskers", "Fluffy", "Mittens", "Socks", "Tiger", "Smokey", "Gizmo", "Oreo", "Luna", "Oliver", "Leo", "Milo", "Charlie", "Simba", "Nala", "Felix", "Garfield", "Tigger", "Chloe", "Bella")

# Twenty words ending in "ding"
ding_words <- c(
  "abounding",
  "astounding",
  "confounding",
  "resounding",
  "surrounding",
  "grounding",
  "founding",
  "pounding",
  "rounding",
  "sounding",
  "bounding",
  "hounding",
  "mounding",
  "wounding",
  "compounding",
  "expounding",
  "propounding",
  "rebounding",
  "unbounding",
  "floundering"
)
```


We can start with the `str_view` function from the `stringr` package to search for patterns in the `words` vector. It returns a visual representation of the matches.

-   `str_view(words, "ding")`: searches for words containing the substring "ding"
-   `str_view(ding_words, "bou|rr")`: searches for words containing the substrings "bou" or "rr". The vertical bar `|` here is a special regex character that represent the Boolean OR operator.

```{r}
#| label: str-view-words
# View the string "ding" 
str_view(ding_words,"ding")

# View the string "bou" or "rr"
str_view(ding_words,"bou|rr")
```

Square brackets enable us to pass mulitple characters to match. If we use `[isk]` with `cat_names` it will match any of these three characters `i`, `s` and `k`:

```{r}
str_view(cat_names,"[isk]")
```
We can invert the pattern by using the negation symbol `^` at the inside our brackets. Now we match everything that isn't `i`, `s`, or `k`.

```{r}
str_view(cat_names,"[^isk]")
```
#### Pattern Matching and Counting

The `str_detect` function is used to identify elements in the `cat_names` vector that contain the pattern "\[isk\]" (i.e., the characters "i", "s", or "k").

-   `str_detect(cat_names, "[isk]")`: returns a logical vector indicating which names contain the pattern
-   `str_count(cat_names, "[isk]")`: counts the number of occurrences of the pattern in each name

## String Replacement

The `str_replace` and `str_replace_all` functions are used to replace occurrences of the pattern "\[isk\]" in the `cat_names` vector with a hyphen (-).

-   `str_replace(cat_names, "[isk]", "-")`: replaces the first occurrence of the pattern in each name
-   `str_replace_all(cat_names, "[isk]", "-")`: replaces all occurrences of the pattern in each name

```{r}
str_detect(cat_names,"(isk)") # Find names with i,s or k

str_count(cat_names,"[isk]")

str_replace(cat_names,"[isk]","-") 
str_replace_all(cat_names,"[isk]","-")
```

Creating the `cat_tibble`
======================================

The code creates a `cat_tibble` dataframe with a single column `cat_id`. The `str_c` function is used to concatenate strings. We're creating a string that looks like `<name>-sex_age>`, where:

* `<` is the literal character
* `cat_names` is the vector of cat names
* `>` is the literal character
* `sample(c("-M_","-F_"), ...)` generates a random sex indicator (-M_ for male or -F_ for female) for each cat
* `sample(3:11, ...)` generates a random age (between 3 and 11) for each cat

```{r}
cat_tibble <- tibble(
  cat_id = str_c("<", cat_names, ">",
                 sample(c("-M_","-F_"),
                        size = length(cat_names),
                      replace = TRUE),
               sample(3:11, size = length(cat_names),
                      replace = TRUE))
)
```

Separating the `cat_id` column into multiple columns
=====================================================

We use the `separate_wider_regex` function from the `tidyr` package to split the `cat_id` column into separate columns based on regular expression patterns.

```{r}
cat_tibble |>
  separate_wider_regex(
    cat_id,
    patterns = c("<",
      name = "[A-Za-z]+", ">-",
      sex = ".","_",
      age = "[0-9]+")
  )
```

The `patterns` argument is a named vector defining the regular expression patterns to extract from the `cat_id` column. Specifically:

* `<` matches the literal `<` character
* `name = "[A-Za-z]+"` extracts one or more alphabetic characters (the cat's name)
* `">-"` matches the literal `>-` characters
* `sex = ".","_"` extracts a single character (`.`) followed by an underscore (`_`) to indicate the sex (M or F)
* `age = "[0-9]+"` extracts one or more digits (the cat's age)

The resulting dataframe will have separate columns for `name`, `sex`, and `age`, extracted from the original `cat_id` column.


```{r}
#| echo: false
#| eval: false

cat_dat <- tibble(
  name = c(
    "Whiskers", "Mittens", "Fluffy", "Tigger", "Smokey",
    "Oreo", "Gizmo", "Luna", "Charlie", "Max",
    "Leo", "Lucy", "Bella", "Simba", "Nala",
    "Oscar", "Milo", "Kitty", "Felix", "Loki"
  ),
  age = sample(1:15, size = 20, replace = TRUE),
  sex = sample(c("Male", "Female"), size = 20, replace = TRUE),
  street = sample(
    c(
      "Highfield Lane",
      "Upper Shirley Avenue",
      "Sherborne Way",
      "Oxford Street",
      "Bedford Square"
    ),
    size = 20,
    replace = TRUE
  ),
  eye_color = sample(
    c("Blue", "Green", "Yellow", "Amber"),
    size = 20,
    replace = TRUE
  ),
  breed = sample(
    c(
      "Classic Tabby",
      "Cornish Rex",
      "Abyssinian",
      "Persian",
      "Bengal",
      "Russian Blue"
    ),
    size = 20,
    replace = TRUE
  )
)



little_dog_names <- c(
  "Peanut",
  "Gizmo",
  "Mochi",
  "Ziggy",
  "Peppa",
  "Taco",
  "Biscuit",
  "Pixie",
  "Noodle",
  "Jellybean"
)

dog_tibble <- tibble(
  dog_id = str_c("[", little_dog_names, "]",
                 sample(c(" M "," F "), 
                        size = length(little_dog_names), 
                      replace = TRUE),  
               sample(3:11, size = length(little_dog_names), 
                      replace = TRUE)))

dog_tibble

dogs <- dog_tibble |> 
  separate_wider_regex(
    dog_id,
    patterns = c("\\[", 
      name = "[A-Za-z]+", "\\] ", 
      sex = "."," ",
      age = "[0-9]+")
  )

# Extra credit count the number of dogs by age
dogs |> 
  group_by(age) |> 
  summarise(n_dogs = n()) |> 
  arrange(age)

# Then filter the dogs with the most common 8.
dogs |> 
  filter(age == 8)
```
